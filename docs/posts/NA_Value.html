<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt" xml:lang="pt"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-02-20">

<title>Tratamento de Dados Ausentes – Wesley Neves</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/tabby.min.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-html-abba60c7b863426f1dd778d2b3fd6e6d.min.css" rel="stylesheet" append-hash="true" data-mode="light">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-065a5179aebd64318d7ea99d77b64a9e.css" rel="stylesheet" id="quarto-text-highlighting-styles">


<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="styles.css">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Tratamento de Dados Ausentes</h1>

<p class="date">2025-02-20</p>
</header>


<h1 id="tratamento-de-valores-ausentesna-no-programa-r">Tratamento de Valores Ausentes(NA) no Programa R</h1>
<p>A detecção e o tratamento de dados ausentes são componentes essenciais em qualquer processo de análise de dados, uma vez que a presença de valores faltantes pode distorcer os resultados de forma significativa. A qualidade e a integridade dos dados são fundamentais para garantir que as conclusões obtidas a partir das análises sejam confiáveis e representativas da realidade que se deseja investigar.</p>
<h2 id="como-ocorrem-os-dados-ausentes" class="anchored">Como ocorrem os dados ausentes?</h2>
<p>Dados ausentes podem ocorrer por diversos motivos, como erros de coleta, falhas técnicas, ou até mesmo por escolhas experimentais. Esses valores faltantes, se não tratados adequadamente, podem levar a viéses nas estimativas, perda de poder estatístico e redução da precisão dos modelos preditivos.</p>
<h2 id="como-resolver-esse-problema" class="anchored">Como resolver esse problema?</h2>
<p>A forma como lidamos com os dados ausentes pode afetar diretamente a validade das análises subsequentes. Estratégias como remoção de dados ausentes, imputação ou modelagem específica para dados ausentes são frequentemente utilizadas para contornar esse problema. A escolha da abordagem depende do tipo de dados, do volume de valores ausentes e dos objetivos da pesquisa. O objetivo final é garantir que as conclusões extraídas não sejam enviesadas ou imprecisas devido à presença desses dados faltantes, proporcionando assim análises mais robustas e decisões mais informadas.</p>
<h1 id="tratamento-dos-dados-no-r">Tratamento dos dados no R</h1>
<h2 id="detecção-de-valores-ausentes" class="anchored">Detecção de valores ausentes:</h2>
<p>A Função que mostra uma tabela bruta com valores lógicos identificando células vazias é</p>
<blockquote>
<p>is.na(Objeto))</p>
</blockquote>
<p>Essa função não é tao interessante para ser usada inicialmente na nossa curadoria de dados, pra isso, podemos utilizar uma função que irá nos responder logicamente (TRUE or FALSE) se o nosso conjunto de dados tem ou não valores ausentes, para isso podemos contar com a ajuda da função <em>any</em>()</p>
<blockquote>
<p>any(is.na(Objeto))</p>
</blockquote>
<p>A partir do resultado dessa função, podemos perguntar ao R quais linhas e colunas estão os valores ausentes:</p>
<blockquote>
<p>which(is.na(Objeto), arr.ind = TRUE)</p>
</blockquote>
<p>Se o nosso conjunto de dados possuir muitos valores ausentes, a lista dessa chamada de função será grande, logo, é mais intuitivo perguntar ao R quantos valores ausentes cada coluna que o meu conjunto de dados possui:</p>
<blockquote>
<p>colSums(is.na(Objeto))</p>
</blockquote>
<h2 id="o-que-fazer-com-os-valores-ausentes-encontrados" class="anchored">O que fazer com os valores ausentes encontrados?</h2>
<p>Existem três alternativas que podemos utilizar para nos livrar dessa incoveniência, sendo elas: excluir, substituir ou estimar dados em detrimento dos valores ausentes. Escolher entre cada uma dessas opções dependerá da quantidade de valores ausentes encontrados no meu conjunto de dados.</p>
<h3 id="poucos-na---substituir-esses-valores-pela-média-mediana-ou-valor-fixo" class="anchored">Poucos NA - Substituir esses valores pela média, mediana ou valor fixo</h3>
<h4 id="média" class="anchored">Média</h4>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (col <span class="cf">in</span> <span class="fu">colnames</span>(SeuDataFrame)) { <span class="cf">if</span> (<span class="fu">is.numeric</span>(SeuDataFrame[[col]])) { SeuDataFrame[[col]][<span class="fu">is.na</span>(SeuDataFrame[[col]])] <span class="ot">&lt;-</span> <span class="fu">mean</span>(SeuDataFrame[[col]], <span class="at">na.rm =</span> <span class="cn">TRUE</span>) } }</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<h4 id="valor-fixo-substituir-por-0" class="anchored">Valor Fixo, substituir por 0</h4>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>SeuDataFrame[<span class="fu">is.na</span>(SeuDataFrame)] <span class="ot">&lt;-</span> <span class="dv">0</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<h3 id="muitos-na-em-poucas-colunas---remover-as-colunas" class="anchored">Muitos NA em poucas colunas - Remover as colunas</h3>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>SeuDataFrame <span class="ot">&lt;-</span> SeuDataFrame[, <span class="fu">colSums</span>(<span class="fu">is.na</span>(SeuDataFrame)) <span class="sc">==</span> <span class="dv">0</span>] <span class="co"># Remove todas as colunas com qualquer NA</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>SeuDataFrame <span class="ot">&lt;-</span> SeuDataFrame[, <span class="fu">colMeans</span>(<span class="fu">is.na</span>(SeuDataFrame)) <span class="sc">&lt;</span> <span class="fl">0.5</span>] <span class="co"># se quiser remover apenas colunas com mais de 50% de NA:</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<h3 id="muitos-na-dispersos-em-várias-linhas---remover-as-linhas" class="anchored">Muitos NA dispersos em várias linhas - Remover as linhas</h3>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>SeuDataFrame <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(SeuDataFrame) <span class="co"># Remove todas as linhas que tenham pelo menos um NA</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<h3 id="para-dados-muito-importantes-podemos-substituir-o-na-pelo-valor-anterior-isso-para-séries-temporais-ou-podemos-utilizar-modelos-de-imputação-interpolação-ou-machine-learning" class="anchored">Para dados muito importantes podemos substituir o NA pelo valor anterior (<strong>isso para séries temporais</strong>) ou podemos utilizar Modelos de Imputação (<strong>interpolação ou machine learning</strong>)</h3>
<h4 id="séries-temporais" class="anchored">Séries Temporais:</h4>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(zoo) </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>SeuDataFrame <span class="ot">&lt;-</span> <span class="fu">na.locf</span>(SeuDataFrame) <span class="co"># Preenche com o último valor não-NA</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<h4 id="modelos-de-imputação" class="anchored">Modelos de Imputação:</h4>
<p>Os <strong>modelos de imputação</strong> são técnicas utilizadas para substituir valores ausentes em um conjunto de dados por estimativas baseadas nas informações disponíveis. A imputação é uma etapa crucial em processos analíticos, especialmente quando a quantidade de dados ausentes é significativa. Ela visa melhorar a qualidade dos dados, preservando sua integridade e evitando que a perda de informações prejudique as conclusões das análises.</p>
<p>Existem várias abordagens para imputação, que podem ser classificadas em <strong>simples</strong> ou <strong>complexas</strong>. A escolha do modelo de imputação depende do tipo de dados, da natureza dos valores ausentes e do impacto potencial na análise. Abaixo, estão algumas das principais abordagens:</p>
<h5 id="imputação-por-médiamedianamoda-imputação-simples" class="anchored">1. <strong>Imputação por Média/Mediana/Moda (Imputação Simples)</strong></h5>
<p>A imputação simples é uma das mais diretas e consiste em substituir os valores ausentes por uma estatística central dos dados observados.</p>
<ul>
<li><p><strong>Média</strong>: Substituir valores ausentes pela média dos valores observados em uma variável numérica.</p></li>
<li><p><strong>Mediana</strong>: Usada especialmente quando os dados são assimétricos, substituindo valores ausentes pela mediana.</p></li>
<li><p><strong>Moda</strong>: Para dados categóricos, os valores ausentes podem ser substituídos pela moda, ou seja, o valor mais frequente.</p></li>
</ul>
<p><strong>Limitações</strong>:</p>
<ul>
<li><p>Não leva em consideração as correlações entre variáveis.</p></li>
<li><p>Pode reduzir a variabilidade dos dados e introduzir viés, especialmente em distribuições assimétricas.</p></li>
</ul>
<h5 id="imputação-por-regressão" class="anchored">2. <strong>Imputação por Regressão</strong></h5>
<p>Este modelo utiliza uma relação estatística entre a variável com dados ausentes e outras variáveis do conjunto de dados para prever os valores ausentes.</p>
<ul>
<li><p><strong>Imputação por Regressão Linear</strong>: Usa uma equação de regressão linear para prever os valores ausentes com base em outras variáveis numéricas.</p></li>
<li><p><strong>Imputação por Regressão Logística</strong>: Utilizada para variáveis categóricas, onde a relação entre a variável ausente e as demais é modelada por regressão logística.</p></li>
</ul>
<p><strong>Limitações</strong>:</p>
<ul>
<li><p>Supõe que a relação entre as variáveis é linear (no caso de regressão linear).</p></li>
<li><p>Pode ser inadequada se a relação entre as variáveis for complexa ou não-linear.</p></li>
</ul>
<h5 id="imputação-por-k-vizinhos-mais-próximos-knn" class="anchored">3. <strong>Imputação por K-Vizinhos Mais Próximos (KNN)</strong></h5>
<p>A imputação por KNN substitui os valores ausentes com base em uma média ponderada dos valores dos <strong>k vizinhos mais próximos</strong>. Este método leva em consideração a similaridade entre os casos para preencher os valores ausentes.</p>
<ul>
<li><strong>KNN Imputation</strong>: A variável ausente é estimada pela média (ou mediana) dos valores das observações mais próximas, com base em uma medida de distância (por exemplo, distância Euclidiana).</li>
</ul>
<p><strong>Limitações</strong>:</p>
<ul>
<li><p>Exige o cálculo de distâncias entre todas as observações.</p></li>
<li><p>A escolha de “k” pode influenciar os resultados.</p></li>
</ul>
<p><strong>Exemplo no R:</strong></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Carregue o pacote</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(VIM)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(missForest)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Carregar o conjunto de dados iris - Não existem valores ausentes aqui</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(iris)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Definir uma semente para reprodutibilidade</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Introduzir valores ausentes aleatórios</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>iris_ausentes <span class="ot">&lt;-</span> <span class="fu">prodNA</span>(iris, <span class="at">noNA =</span> <span class="fl">0.2</span>) <span class="co"># Função para adicionar valores ausentes em posições aleatórias, o valor 0.2 produz muitos valores ausentes, tente reduzir esse valor para testar.</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Imputação com KNN</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>iris_imputados <span class="ot">&lt;-</span> <span class="fu">kNN</span>(iris_ausentes, <span class="at">k =</span> <span class="dv">5</span>)  <span class="co"># k=5 significa que vamos considerar os 5 vizinhos mais próximos</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><strong>Exibir os dados estimados e reais lado a lado<br>
</strong></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Criar uma máscara dos valores que foram imputados</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>mascara_NA <span class="ot">&lt;-</span> <span class="fu">is.na</span>(iris_ausentes)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Extrair apenas os valores imputados e seus valores reais correspondentes</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>valores_imputados <span class="ot">&lt;-</span> iris_imputados[mascara_NA]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>valores_reais <span class="ot">&lt;-</span> iris[mascara_NA]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Criar um data frame para visualizar as comparações</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>comparacao <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">Valor_Real =</span> valores_reais,</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">Valor_Imputado =</span> valores_imputados</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Mostrar a tabela de comparação</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(comparacao)</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>No próximo tópico será abordado testes para verificar o poder do teste e o tamanho de efeito, tente aplicar aqui também para verificar a confiabilidade da estimativa.</p>
<h5 id="imputação-por-modelos-baseados-em-árvores-ex-missforest" class="anchored">4. <strong>Imputação por Modelos Baseados em Árvores (ex: MissForest)</strong></h5>
<p>O <strong>MissForest</strong> é um modelo de imputação baseado em <strong>árvores de decisão</strong>. Ele trata dados ausentes como variáveis a serem preditas e usa o algoritmo <strong>Random Forest</strong> para prever esses valores ausentes. A imputação é feita de forma iterativa, onde os valores imputados em cada iteração são utilizados para ajustar o modelo até que uma solução estável seja alcançada.</p>
<p><strong>Vantagens</strong>:</p>
<ul>
<li><p>Não assume distribuições específicas para os dados (flexível).</p></li>
<li><p>Lida bem com variáveis categóricas e numéricas simultaneamente.</p></li>
</ul>
<p><strong>Limitações</strong>:</p>
<ul>
<li><p>Requer mais poder computacional devido à complexidade dos algoritmos de árvores.</p></li>
<li><p>Pode ser mais lento para grandes conjuntos de dados.</p></li>
</ul>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(missForest) </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>SeuDataFrame <span class="ot">&lt;-</span> <span class="fu">missForest</span>(SeuDataFrame)<span class="sc">$</span>ximp <span class="co">#Salva um novo data.frame com dados estimados</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>SeuDataFrame<span class="sc">$</span>OOBerror <span class="co"># estimativa do erro do resultado final</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>SeuDataFrame<span class="sc">$</span>error <span class="co">#o erro verdadeiro</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Essa técnica Substitui temporariamente os NA por uma estimativa inicial, geralmente a média (para variáveis numéricas) ou a moda (para categóricas).</p>
<p><strong>Predição com Random Forest:</strong></p>
<ul>
<li><p>Para cada variável com NA, ela é tratada como variável dependente (y).</p></li>
<li><p>As outras colunas sem NA são usadas como preditores (X).</p></li>
<li><p>Um modelo de Random Forest é treinado para prever os valores ausentes.</p></li>
<li><p>Os valores ausentes são substituídos pelas previsões do modelo.</p></li>
</ul>
<p><strong>NRMSE (Normalized Root Mean Square)</strong></p>
<p>É o Erro quadrático médio normalizado, uma métrica usada para avaliar a qualidade da imputação de valores ausentes quando utilizamos métodos como missForest(). Ele mede o erro médio da imputação normalizado pelo intervalo ou desvio padrão dos valores verdadeiros.</p>
<p><strong>Como interpretar o NRMSE?</strong></p>
<ul>
<li><p><strong>NRMSE próximo de 0</strong> → A imputação foi excelente (os valores imputados estão muito próximos dos valores reais).</p></li>
<li><p><strong>NRMSE entre 0.1 e 0.5</strong> → A imputação é razoável, mas pode haver erros consideráveis.</p></li>
<li><p><strong>NRMSE &gt; 0.5</strong> → A imputação tem alto erro e pode não ser confiável.</p></li>
</ul>
<p>Em geral, quanto menor o NRMSE, melhor a imputação!</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(missForest)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(iris) <span class="co"># Conjunto de dados que não possuem valores ausentes.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">81</span>) <span class="co"># Para padronização</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>iris.ausentes <span class="ot">&lt;-</span> <span class="fu">prodNA</span>(iris, <span class="at">noNA =</span> <span class="fl">0.2</span>) </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="fu">any</span>(<span class="fu">is.na</span>(iris.ausentes))</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="fu">which</span>(<span class="fu">is.na</span>(iris.ausentes), <span class="at">arr.ind =</span> <span class="cn">TRUE</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="fu">colSums</span>(<span class="fu">is.na</span>(iris.ausentes))</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>iris.estimadosT <span class="ot">&lt;-</span> <span class="fu">missForest</span>(iris.ausentes, <span class="at">xtrue =</span> iris, <span class="at">verbose =</span> <span class="cn">TRUE</span>) <span class="co"># verbose mostra o que a função está fazendo</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><strong>Estimativa do Erro</strong></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>iris.estimadosT<span class="sc">$</span>OOBerror</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><strong>Estimativa verdadeira do Erro</strong></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>iris.estimadosT<span class="sc">$</span>error</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Se as estimativas dos erros estiverem confortáveis <em>(O PFC mostra a porcentagem das variáveis que não foram corretamente estimadas)</em> salve os dados em outro objeto:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>iris.estimados <span class="ot">&lt;-</span> iris.estimados<span class="sc">$</span>ximp</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><strong>Comparar os resultados estimados com os valores reais:</strong></p>
<p>Podemos comparar diretamente (visualmente) as duas planilhas:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Criar uma máscara dos valores que foram imputados</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>mascara_NA <span class="ot">&lt;-</span> <span class="fu">is.na</span>(iris.ausentes)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Extrair apenas os valores imputados e seus valores reais correspondentes</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>valores_imputados <span class="ot">&lt;-</span> iris.estimados[mascara_NA]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>valores_reais <span class="ot">&lt;-</span> iris[mascara_NA]</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Criar um data frame para visualizar as comparações</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>comparacao <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">Valor_Real =</span> valores_reais,</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">Valor_Imputado =</span> valores_imputados</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Mostrar a tabela de comparação</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(comparacao)</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><strong>Técnicas descritivas e inferenciais para verificar a confiabilidade dos valores imputados pelo Random Forest:</strong></p>
<p>Primeiro precisamos remover as variáveis categóricas, nesse primeiro momento, iremos verificar a confiabilidade da privisão do modelo com dados numéricos.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Filtrar apenas os valores numéricos (caso tenha variáveis categóricas)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>valores_reais_num <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(valores_reais)  </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>valores_imputados_num <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(valores_imputados)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Remover possíveis NAs que possam surgir ao converter os dados</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>valores_reais_num <span class="ot">&lt;-</span> valores_reais_num[<span class="sc">!</span><span class="fu">is.na</span>(valores_reais_num)]</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>valores_imputados_num <span class="ot">&lt;-</span> valores_imputados_num[<span class="sc">!</span><span class="fu">is.na</span>(valores_imputados_num)]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcular variância e desvio padrão para os valores reais</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>var_real <span class="ot">&lt;-</span> <span class="fu">var</span>(valores_reais_num)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>sd_real <span class="ot">&lt;-</span> <span class="fu">sd</span>(valores_reais_num)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcular variância e desvio padrão para os valores imputados</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>var_imputado <span class="ot">&lt;-</span> <span class="fu">var</span>(valores_imputados_num)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>sd_imputado <span class="ot">&lt;-</span> <span class="fu">sd</span>(valores_imputados_num)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Criar um data frame com os resultados</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>resultado_variancia_desvio <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  <span class="at">Estatistica =</span> <span class="fu">c</span>(<span class="st">"Variância"</span>, <span class="st">"Desvio Padrão"</span>),</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>  <span class="at">Valores_Reais =</span> <span class="fu">c</span>(var_real, sd_real),</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>  <span class="at">Valores_Imputados =</span> <span class="fu">c</span>(var_imputado, sd_imputado)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Mostrar os resultados</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(resultado_variancia_desvio)</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Nessa etapa percebemos que os dois conjuntos de dados possuem variações próximas um do outro, mas para verificar se de fato essas variações são homogêneas ou não, precisaremos utilizar algumas análises para primeiro verificar a normalidade dos dados para só após aplicar um teste inferencial.</p>
<p><strong>Verificar a normalidade dos dados:</strong></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>shapiro_real <span class="ot">&lt;-</span> <span class="fu">shapiro.test</span>(valores_reais_num)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>shapiro_imputado <span class="ot">&lt;-</span> <span class="fu">shapiro.test</span>(valores_imputados_num)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Criar data frame com os resultados</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>resultado <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">Conjunto =</span> <span class="fu">c</span>(<span class="st">"Valores Reais"</span>, <span class="st">"Valores Imputados"</span>),</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">W_Statistic =</span> <span class="fu">c</span>(shapiro_real<span class="sc">$</span>statistic, shapiro_imputado<span class="sc">$</span>statistic),</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">p_Value =</span> <span class="fu">c</span>(shapiro_real<span class="sc">$</span>p.value, shapiro_imputado<span class="sc">$</span>p.value)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span>(resultado)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="er">}</span></span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>A função shapiro retorna uma tabela com os valores do teste estatístico W e o p-valor associado ao teste. A hipótese nula do teste shapiro é que os dados seguem uma <strong>distribuição normal</strong>, logo, se o p-valor for maior que o alfa (nível de significância) <em>não rejeitamos a hipótese nula e os dados são normais</em>.</p>
<p>Se o p-valor for menor que o alfa, nós rejeitamos a hipótese nula e os dados não são normais.</p>
<p>O W (estatística do teste) mede o quanto os dados se aproximam de uma distribuição normal. Quanto mais próximo de 1, mais próximo os dados estão de uma distribuição normal. Valores altos de W pode indicar a presença de outliers, ou até mesmo assimetria e curtose nos dados.</p>
<p><strong>Teste de Wilcoxon pareado para comparar os valores reais e imputados</strong></p>
<p>Como os dados não seguem uma distribuição normal dos dados, iremos utilizar um teste não paramétrico para comparar as amostras antes e depois da estimativa.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>wilcox_test <span class="ot">&lt;-</span> <span class="fu">wilcox.test</span>(valores_reais_num, valores_imputados_num, <span class="at">paired =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Exibir o p-valor</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(wilcox_test<span class="sc">$</span>p.value)</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Se p &lt; 0.05 → Indica que existem diferenças significativas entre os grupos (rejeitamos a hipótese nula de que as distribuições são iguais).</p>
<p>O p-valor encontrado foi <strong>0.059</strong> que está ligeiramente acima de 0.05, indicando que não há uma diferença estatisticamente significativa entre os valores imputados e os valores reais, mas está bem próximo do limiar.</p>
<p><strong>Comparar as Variâncias - Teste de Levene</strong></p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(car)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">leveneTest</span>(<span class="fu">c</span>(valores_reais_num, valores_imputados_num), </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">group =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Reais"</span>, <span class="st">"Imputados"</span>), </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">c</span>(<span class="fu">length</span>(valores_reais_num), <span class="fu">length</span>(valores_imputados_num))))</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>O p-valor indica que não existem diferenças significativas nas variâncias dos grupos comparados.</p>
<p><strong>Tamanho de Efeito:</strong> É uma medida estatística que quantifica a <strong>magnitude</strong> de uma diferença ou relacionamento entre grupos ou variáveis, independentemente do tamanho da amostra. Em outras palavras, enquanto os testes de significância estatística (como o <strong>teste t</strong> ou <strong>ANOVA</strong>) nos dizem se um efeito é <strong>estatisticamente significativo</strong>, o <strong>tamanho de efeito</strong> nos ajuda a entender <strong>quão grande ou relevante</strong> esse efeito é em termos práticos ou reais.</p>
<p><strong>Importância do Tamanho de Efeito</strong></p>
<ol type="1">
<li><p><strong>Avaliação da Relevância Prática</strong>: Embora um teste estatístico possa indicar que uma diferença entre grupos é <strong>estatisticamente significativa</strong>, o tamanho de efeito nos informa se essa diferença é <strong>importante</strong> na prática. Isso é crucial porque uma diferença pequena, mas estatisticamente significativa, pode não ter relevância prática em contextos do mundo real. O tamanho de efeito ajuda a evitar essa falácia, fornecendo uma visão mais clara do impacto real.</p></li>
<li><p><strong>Comparação entre Estudos</strong>: O tamanho de efeito permite comparar resultados de diferentes estudos, mesmo que eles tenham usado diferentes tamanhos de amostra. Isso é importante em metanálises, onde os dados de múltiplos estudos são combinados para tirar conclusões gerais. Quando você tem o tamanho de efeito, pode comparar a força de uma relação ou diferença em diferentes contextos e condições experimentais, independentemente da amostra.</p></li>
<li><p><strong>Planejamento de Estudos</strong>: O tamanho de efeito é fundamental para o <strong>planejamento de pesquisas</strong> e <strong>cálculo do poder estatístico</strong>. Ao conhecer o tamanho do efeito esperado, os pesquisadores podem determinar o tamanho da amostra necessário para detectar um efeito com uma probabilidade adequada (poder estatístico). Isso é crucial para garantir que os estudos não sejam nem excessivamente pequenos (não detectando um efeito verdadeiro) nem excessivamente grandes (com um custo desnecessário).</p></li>
<li><p><strong>Interpretação de Resultados</strong>: Em contextos acadêmicos e profissionais, o tamanho de efeito ajuda a <strong>interpretar</strong> a significância dos resultados de forma mais contextualizada. Um p-valor de 0.05, por exemplo, indica uma probabilidade de erro de 5%, mas não fornece informações sobre a magnitude do efeito. Já o tamanho de efeito oferece uma medida mais direta de quão grande é o impacto observado.</p></li>
<li><p><strong>Compreensão da Variabilidade</strong>: O tamanho de efeito também ajuda a compreender a <strong>variabilidade</strong> entre grupos ou dentro de um conjunto de dados. Em vez de focar apenas em se a diferença é significativa ou não, o tamanho de efeito oferece uma visão mais detalhada da <strong>intensidade</strong> ou <strong>força</strong> dessa diferença. Esse tipo de compreensão é útil em várias áreas, como psicologia, biologia e ciências sociais, onde os efeitos pequenos, mas consistentes, podem ser mais importantes do que grandes efeitos que ocorrem raramente.</p></li>
</ol>
<p><strong>Tipos de Tamanho de Efeito</strong></p>
<p>Existem várias formas de calcular o tamanho de efeito, e a escolha depende do tipo de análise:</p>
<ol type="1">
<li><p><strong>d de Cohen</strong>: Mede a diferença entre duas médias em termos do desvio padrão. Um valor de 0.2 indica um efeito pequeno, 0.5 um efeito médio, e 0.8 um grande efeito.</p></li>
<li><p><strong>r de Pearson</strong>: Mede a força e a direção de uma relação linear entre duas variáveis. Um valor de 0.1 a 0.3 indica um efeito pequeno, 0.3 a 0.5 um efeito médio e 0.5 ou mais um grande efeito.</p></li>
<li><p><strong>η² (eta quadrado)</strong>: Usado em ANOVA para medir a proporção de variabilidade explicada pela variável independente.</p></li>
<li><p><strong>Odds ratio e risco relativo</strong>: Usados em estudos de caso-controle ou estudos epidemiológicos para medir a força da associação entre uma variável independente e um evento.</p></li>
</ol>
<p><strong>Exemplo de Interpretação do Tamanho de Efeito</strong></p>
<p>Imaginemos um estudo que investiga a eficácia de um novo medicamento comparado a um placebo. O teste estatístico pode indicar que a diferença entre os dois grupos é <strong>estatisticamente significativa</strong> (p-valor &lt; 0.05), mas o tamanho de efeito pode ser pequeno, digamos, um <strong>d de Cohen = 0.2</strong>. Isso sugere que, embora o medicamento tenha mostrado um efeito significativo, a <strong>magnitude</strong> desse efeito é pequena, o que pode implicar que, na prática, o medicamento tem pouco impacto em relação ao placebo, apesar da diferença ser significativa.</p>
<p>Por outro lado, se o tamanho de efeito for <strong>d = 0.8</strong>, o efeito seria considerado <strong>grande</strong>, o que indicaria que o medicamento tem um impacto substancial e relevante em comparação com o placebo.</p>
<p>Já que utilizamos o teste de WIlcoxon, iremos utilizar o tamanho de efeito apropriado a esse teste (para conjunto de dados não normais).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rstatix)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(coin)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>dados <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">valores =</span> <span class="fu">c</span>(valores_reais_num, valores_imputados_num),</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">grupo =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Reais"</span>, <span class="st">"Imputados"</span>), </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>              <span class="fu">c</span>(<span class="fu">length</span>(valores_reais_num), <span class="fu">length</span>(valores_imputados_num)))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="fu">wilcox_effsize</span>(dados, <span class="at">formula =</span> valores <span class="sc">~</span> grupo)</span></code></pre></div><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>O valor de efeito (0.0187) está muito próximo de zero e a classificação como “small” sugere que, embora exista uma diferença entre os grupos Imputados e Reais, essa diferença é muito pequena.</p>
<h5 id="imputação-múltipla-multiple-imputation---pacote-mice-no-r" class="anchored">5. <strong>Imputação Múltipla (Multiple Imputation - Pacote mice no R)</strong></h5>
<p>A imputação múltipla é uma técnica mais avançada e robusta, na qual os valores ausentes são imputados várias vezes, criando diferentes conjuntos de dados “imputados”. Cada conjunto de dados é analisado separadamente e as estimativas finais são combinadas de forma a refletir a incerteza sobre os valores imputados.</p>
<ul>
<li><strong>MICE (Multivariate Imputation by Chained Equations)</strong>: Método popular de imputação múltipla, no qual um conjunto de equações é utilizado para imputar as variáveis ausentes uma de cada vez, de forma iterativa.</li>
</ul>
<p><strong>Vantagens</strong>:</p>
<ul>
<li><p>Considera a incerteza associada aos valores imputados.</p></li>
<li><p>Produz estimativas mais precisas e conservadoras, especialmente em datasets complexos.</p></li>
</ul>
<p><strong>Limitações</strong>:</p>
<ul>
<li><p>Requer conhecimento avançado em estatísticas.</p></li>
<li><p>Não é tão boa para dados categóricos.</p></li>
<li><p>Mais caro computacionalmente, pois envolve múltiplas imputações e análises.</p></li>
</ul>
<h5 id="imputação-com-redes-neurais-pacote-h2o-no-r" class="anchored">6. <strong>Imputação com Redes Neurais (Pacote h2o no R)</strong></h5>
<p>As redes neurais podem ser usadas para imputar dados faltantes, especialmente em conjuntos de dados grandes e complexos. Redes neurais artificiais podem aprender padrões complexos entre as variáveis para prever valores ausentes.</p>
<p><strong>Vantagens</strong>:</p>
<ul>
<li><p>Capacidade de modelar relações não-lineares complexas entre as variáveis.</p></li>
<li><p>Pode ser eficaz em dados grandes e com muitos atributos.</p></li>
</ul>
<p><strong>Limitações</strong>:</p>
<ul>
<li><p>Requer uma quantidade considerável de dados para ser eficaz.</p></li>
<li><p>Pode ser difícil de interpretar, tornando-a menos transparente que outros métodos.</p></li>
</ul>
<h5 id="conclusão" class="anchored"><strong>Conclusão</strong></h5>
<p>A escolha do modelo de imputação depende do <strong>tipo de dados</strong>, da <strong>quantidade de dados ausentes</strong>, do <strong>objetivo da análise</strong> e da <strong>complexidade computacional</strong> que você está disposto a enfrentar. Embora as técnicas simples como a imputação por média ou mediana possam ser rápidas e fáceis de implementar, abordagens mais sofisticadas, como <strong>imputação múltipla</strong> ou <strong>MissForest</strong>, são mais robustas e geralmente fornecem resultados mais precisos e confiáveis, especialmente em conjuntos de dados mais complexos.</p>
<p>Cada técnica tem suas vantagens e desvantagens, e é importante analisar os dados de forma cuidadosa antes de escolher a abordagem mais apropriada para o tratamento de dados ausentes.</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/gml.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>


<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
    tabsets.forEach(function(tabset) {
      const tabby = new Tabby('#' + tabset.id);
    });
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiada");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiada");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'light-border',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>




</body></html>